// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmos/evm/vm/v1/sponsorship.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// FeeSponsor defines a fee sponsorship relationship where a sponsor pays gas fees
// for a beneficiary's transactions
type FeeSponsor struct {
	// sponsor is the hex address paying the fees
	Sponsor string `protobuf:"bytes,1,opt,name=sponsor,proto3" json:"sponsor,omitempty"`
	// beneficiary is the hex address whose transactions are sponsored
	Beneficiary string `protobuf:"bytes,2,opt,name=beneficiary,proto3" json:"beneficiary,omitempty"`
	// max_gas_per_tx is the maximum gas limit this sponsorship covers per transaction
	MaxGasPerTx uint64 `protobuf:"varint,3,opt,name=max_gas_per_tx,json=maxGasPerTx,proto3" json:"max_gas_per_tx,omitempty"`
	// total_gas_budget is the total amount of gas remaining in this sponsorship
	TotalGasBudget uint64 `protobuf:"varint,4,opt,name=total_gas_budget,json=totalGasBudget,proto3" json:"total_gas_budget,omitempty"`
	// expiration_height is the block height when this sponsorship expires
	ExpirationHeight int64 `protobuf:"varint,5,opt,name=expiration_height,json=expirationHeight,proto3" json:"expiration_height,omitempty"`
	// created_at is the block height when this sponsorship was created
	CreatedAt int64 `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// sponsorship_id is a unique identifier for this sponsorship
	SponsorshipId string `protobuf:"bytes,7,opt,name=sponsorship_id,json=sponsorshipId,proto3" json:"sponsorship_id,omitempty"`
	// is_active indicates if this sponsorship is currently active
	IsActive bool `protobuf:"varint,8,opt,name=is_active,json=isActive,proto3" json:"is_active,omitempty"`
	// conditions defines optional advanced conditions for the sponsorship
	Conditions *SponsorshipConditions `protobuf:"bytes,9,opt,name=conditions,proto3" json:"conditions,omitempty"`
	// gas_used tracks total gas consumed by this sponsorship
	GasUsed uint64 `protobuf:"varint,10,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
	// transaction_count tracks number of transactions sponsored
	TransactionCount uint64 `protobuf:"varint,11,opt,name=transaction_count,json=transactionCount,proto3" json:"transaction_count,omitempty"`
}

func (m *FeeSponsor) Reset()         { *m = FeeSponsor{} }
func (m *FeeSponsor) String() string { return proto.CompactTextString(m) }
func (*FeeSponsor) ProtoMessage()    {}
func (*FeeSponsor) Descriptor() ([]byte, []int) {
	return fileDescriptor_2578bb4556ee5dab, []int{0}
}
func (m *FeeSponsor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FeeSponsor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FeeSponsor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FeeSponsor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FeeSponsor.Merge(m, src)
}
func (m *FeeSponsor) XXX_Size() int {
	return m.Size()
}
func (m *FeeSponsor) XXX_DiscardUnknown() {
	xxx_messageInfo_FeeSponsor.DiscardUnknown(m)
}

var xxx_messageInfo_FeeSponsor proto.InternalMessageInfo

func (m *FeeSponsor) GetSponsor() string {
	if m != nil {
		return m.Sponsor
	}
	return ""
}

func (m *FeeSponsor) GetBeneficiary() string {
	if m != nil {
		return m.Beneficiary
	}
	return ""
}

func (m *FeeSponsor) GetMaxGasPerTx() uint64 {
	if m != nil {
		return m.MaxGasPerTx
	}
	return 0
}

func (m *FeeSponsor) GetTotalGasBudget() uint64 {
	if m != nil {
		return m.TotalGasBudget
	}
	return 0
}

func (m *FeeSponsor) GetExpirationHeight() int64 {
	if m != nil {
		return m.ExpirationHeight
	}
	return 0
}

func (m *FeeSponsor) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *FeeSponsor) GetSponsorshipId() string {
	if m != nil {
		return m.SponsorshipId
	}
	return ""
}

func (m *FeeSponsor) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *FeeSponsor) GetConditions() *SponsorshipConditions {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *FeeSponsor) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

func (m *FeeSponsor) GetTransactionCount() uint64 {
	if m != nil {
		return m.TransactionCount
	}
	return 0
}

// SponsorshipConditions defines optional advanced conditions for sponsorships
type SponsorshipConditions struct {
	// whitelisted_contracts restricts sponsorship to only these contract addresses
	// Empty list means all contracts allowed
	WhitelistedContracts []string `protobuf:"bytes,1,rep,name=whitelisted_contracts,json=whitelistedContracts,proto3" json:"whitelisted_contracts,omitempty"`
	// max_tx_value restricts sponsorship to transactions with value <= this amount
	// Zero means no restriction
	MaxTxValue cosmossdk_io_math.Int `protobuf:"bytes,2,opt,name=max_tx_value,json=maxTxValue,proto3,customtype=cosmossdk.io/math.Int" json:"max_tx_value"`
	// daily_gas_limit restricts total gas usage per day
	// Zero means no daily limit
	DailyGasLimit uint64 `protobuf:"varint,3,opt,name=daily_gas_limit,json=dailyGasLimit,proto3" json:"daily_gas_limit,omitempty"`
	// require_signature requires sponsor to co-sign each transaction
	RequireSignature bool `protobuf:"varint,4,opt,name=require_signature,json=requireSignature,proto3" json:"require_signature,omitempty"`
}

func (m *SponsorshipConditions) Reset()         { *m = SponsorshipConditions{} }
func (m *SponsorshipConditions) String() string { return proto.CompactTextString(m) }
func (*SponsorshipConditions) ProtoMessage()    {}
func (*SponsorshipConditions) Descriptor() ([]byte, []int) {
	return fileDescriptor_2578bb4556ee5dab, []int{1}
}
func (m *SponsorshipConditions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SponsorshipConditions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SponsorshipConditions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SponsorshipConditions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SponsorshipConditions.Merge(m, src)
}
func (m *SponsorshipConditions) XXX_Size() int {
	return m.Size()
}
func (m *SponsorshipConditions) XXX_DiscardUnknown() {
	xxx_messageInfo_SponsorshipConditions.DiscardUnknown(m)
}

var xxx_messageInfo_SponsorshipConditions proto.InternalMessageInfo

func (m *SponsorshipConditions) GetWhitelistedContracts() []string {
	if m != nil {
		return m.WhitelistedContracts
	}
	return nil
}

func (m *SponsorshipConditions) GetDailyGasLimit() uint64 {
	if m != nil {
		return m.DailyGasLimit
	}
	return 0
}

func (m *SponsorshipConditions) GetRequireSignature() bool {
	if m != nil {
		return m.RequireSignature
	}
	return false
}

// SponsorshipRegistry maintains all active sponsorships
type SponsorshipRegistry struct {
	// sponsorships is a map of beneficiary address to their sponsorships
	Sponsorships map[string]*BeneficiarySponsorships `protobuf:"bytes,1,rep,name=sponsorships,proto3" json:"sponsorships,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SponsorshipRegistry) Reset()         { *m = SponsorshipRegistry{} }
func (m *SponsorshipRegistry) String() string { return proto.CompactTextString(m) }
func (*SponsorshipRegistry) ProtoMessage()    {}
func (*SponsorshipRegistry) Descriptor() ([]byte, []int) {
	return fileDescriptor_2578bb4556ee5dab, []int{2}
}
func (m *SponsorshipRegistry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SponsorshipRegistry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SponsorshipRegistry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SponsorshipRegistry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SponsorshipRegistry.Merge(m, src)
}
func (m *SponsorshipRegistry) XXX_Size() int {
	return m.Size()
}
func (m *SponsorshipRegistry) XXX_DiscardUnknown() {
	xxx_messageInfo_SponsorshipRegistry.DiscardUnknown(m)
}

var xxx_messageInfo_SponsorshipRegistry proto.InternalMessageInfo

func (m *SponsorshipRegistry) GetSponsorships() map[string]*BeneficiarySponsorships {
	if m != nil {
		return m.Sponsorships
	}
	return nil
}

// BeneficiarySponsorships holds all sponsorships for a single beneficiary
type BeneficiarySponsorships struct {
	Sponsors []*FeeSponsor `protobuf:"bytes,1,rep,name=sponsors,proto3" json:"sponsors,omitempty"`
}

func (m *BeneficiarySponsorships) Reset()         { *m = BeneficiarySponsorships{} }
func (m *BeneficiarySponsorships) String() string { return proto.CompactTextString(m) }
func (*BeneficiarySponsorships) ProtoMessage()    {}
func (*BeneficiarySponsorships) Descriptor() ([]byte, []int) {
	return fileDescriptor_2578bb4556ee5dab, []int{3}
}
func (m *BeneficiarySponsorships) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeneficiarySponsorships) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeneficiarySponsorships.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeneficiarySponsorships) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeneficiarySponsorships.Merge(m, src)
}
func (m *BeneficiarySponsorships) XXX_Size() int {
	return m.Size()
}
func (m *BeneficiarySponsorships) XXX_DiscardUnknown() {
	xxx_messageInfo_BeneficiarySponsorships.DiscardUnknown(m)
}

var xxx_messageInfo_BeneficiarySponsorships proto.InternalMessageInfo

func (m *BeneficiarySponsorships) GetSponsors() []*FeeSponsor {
	if m != nil {
		return m.Sponsors
	}
	return nil
}

// SponsorshipUsageRecord tracks gas usage per day for daily limits
type SponsorshipUsageRecord struct {
	SponsorshipId string `protobuf:"bytes,1,opt,name=sponsorship_id,json=sponsorshipId,proto3" json:"sponsorship_id,omitempty"`
	Date          int64  `protobuf:"varint,2,opt,name=date,proto3" json:"date,omitempty"`
	GasUsed       uint64 `protobuf:"varint,3,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
}

func (m *SponsorshipUsageRecord) Reset()         { *m = SponsorshipUsageRecord{} }
func (m *SponsorshipUsageRecord) String() string { return proto.CompactTextString(m) }
func (*SponsorshipUsageRecord) ProtoMessage()    {}
func (*SponsorshipUsageRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_2578bb4556ee5dab, []int{4}
}
func (m *SponsorshipUsageRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SponsorshipUsageRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SponsorshipUsageRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SponsorshipUsageRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SponsorshipUsageRecord.Merge(m, src)
}
func (m *SponsorshipUsageRecord) XXX_Size() int {
	return m.Size()
}
func (m *SponsorshipUsageRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_SponsorshipUsageRecord.DiscardUnknown(m)
}

var xxx_messageInfo_SponsorshipUsageRecord proto.InternalMessageInfo

func (m *SponsorshipUsageRecord) GetSponsorshipId() string {
	if m != nil {
		return m.SponsorshipId
	}
	return ""
}

func (m *SponsorshipUsageRecord) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *SponsorshipUsageRecord) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

// BeneficiarySponsorshipIndex stores list of sponsorship IDs for a beneficiary
type BeneficiarySponsorshipIndex struct {
	SponsorshipIds []string `protobuf:"bytes,1,rep,name=sponsorship_ids,json=sponsorshipIds,proto3" json:"sponsorship_ids,omitempty"`
}

func (m *BeneficiarySponsorshipIndex) Reset()         { *m = BeneficiarySponsorshipIndex{} }
func (m *BeneficiarySponsorshipIndex) String() string { return proto.CompactTextString(m) }
func (*BeneficiarySponsorshipIndex) ProtoMessage()    {}
func (*BeneficiarySponsorshipIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_2578bb4556ee5dab, []int{5}
}
func (m *BeneficiarySponsorshipIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BeneficiarySponsorshipIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BeneficiarySponsorshipIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BeneficiarySponsorshipIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BeneficiarySponsorshipIndex.Merge(m, src)
}
func (m *BeneficiarySponsorshipIndex) XXX_Size() int {
	return m.Size()
}
func (m *BeneficiarySponsorshipIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_BeneficiarySponsorshipIndex.DiscardUnknown(m)
}

var xxx_messageInfo_BeneficiarySponsorshipIndex proto.InternalMessageInfo

func (m *BeneficiarySponsorshipIndex) GetSponsorshipIds() []string {
	if m != nil {
		return m.SponsorshipIds
	}
	return nil
}

// DailyUsage tracks gas usage for a specific day
type DailyUsage struct {
	GasUsed uint64 `protobuf:"varint,1,opt,name=gas_used,json=gasUsed,proto3" json:"gas_used,omitempty"`
}

func (m *DailyUsage) Reset()         { *m = DailyUsage{} }
func (m *DailyUsage) String() string { return proto.CompactTextString(m) }
func (*DailyUsage) ProtoMessage()    {}
func (*DailyUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_2578bb4556ee5dab, []int{6}
}
func (m *DailyUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DailyUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DailyUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DailyUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DailyUsage.Merge(m, src)
}
func (m *DailyUsage) XXX_Size() int {
	return m.Size()
}
func (m *DailyUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_DailyUsage.DiscardUnknown(m)
}

var xxx_messageInfo_DailyUsage proto.InternalMessageInfo

func (m *DailyUsage) GetGasUsed() uint64 {
	if m != nil {
		return m.GasUsed
	}
	return 0
}

func init() {
	proto.RegisterType((*FeeSponsor)(nil), "cosmos.evm.vm.v1.FeeSponsor")
	proto.RegisterType((*SponsorshipConditions)(nil), "cosmos.evm.vm.v1.SponsorshipConditions")
	proto.RegisterType((*SponsorshipRegistry)(nil), "cosmos.evm.vm.v1.SponsorshipRegistry")
	proto.RegisterMapType((map[string]*BeneficiarySponsorships)(nil), "cosmos.evm.vm.v1.SponsorshipRegistry.SponsorshipsEntry")
	proto.RegisterType((*BeneficiarySponsorships)(nil), "cosmos.evm.vm.v1.BeneficiarySponsorships")
	proto.RegisterType((*SponsorshipUsageRecord)(nil), "cosmos.evm.vm.v1.SponsorshipUsageRecord")
	proto.RegisterType((*BeneficiarySponsorshipIndex)(nil), "cosmos.evm.vm.v1.BeneficiarySponsorshipIndex")
	proto.RegisterType((*DailyUsage)(nil), "cosmos.evm.vm.v1.DailyUsage")
}

func init() {
	proto.RegisterFile("cosmos/evm/vm/v1/sponsorship.proto", fileDescriptor_2578bb4556ee5dab)
}

var fileDescriptor_2578bb4556ee5dab = []byte{
	// 742 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xc1, 0x6e, 0xeb, 0x44,
	0x14, 0xcd, 0xbc, 0xe4, 0xbd, 0x26, 0x37, 0xaf, 0x69, 0x3a, 0xb4, 0x60, 0x5a, 0x9a, 0x58, 0x41,
	0xd0, 0x20, 0x24, 0x5b, 0x6d, 0x17, 0x54, 0xdd, 0x54, 0x4d, 0xa1, 0xa1, 0x12, 0x0b, 0xe4, 0xb4,
	0x2c, 0x60, 0x61, 0x4d, 0xec, 0xa9, 0x33, 0x34, 0xf6, 0x04, 0xcf, 0x38, 0x38, 0x7f, 0xc1, 0x27,
	0xf0, 0x25, 0xac, 0xbb, 0xec, 0x12, 0xb1, 0xa8, 0x50, 0xbb, 0xe9, 0x67, 0xa0, 0x19, 0x3b, 0x8d,
	0x43, 0x03, 0x92, 0x17, 0x9e, 0x73, 0xcf, 0xdc, 0x33, 0x67, 0xee, 0xbd, 0x03, 0x1d, 0x8f, 0x8b,
	0x90, 0x0b, 0x9b, 0x4e, 0x43, 0x5b, 0x7d, 0x07, 0xb6, 0x98, 0xf0, 0x48, 0xf0, 0x58, 0x8c, 0xd8,
	0xc4, 0x9a, 0xc4, 0x5c, 0x72, 0xdc, 0xcc, 0x38, 0x16, 0x9d, 0x86, 0x96, 0xfa, 0x0e, 0x76, 0xb6,
	0x02, 0x1e, 0x70, 0x1d, 0xb4, 0xd5, 0x5f, 0xc6, 0xdb, 0x69, 0x07, 0x9c, 0x07, 0x63, 0x6a, 0xeb,
	0xd5, 0x30, 0xb9, 0xb1, 0x25, 0x0b, 0xa9, 0x90, 0x24, 0xcc, 0x13, 0x75, 0xfe, 0x28, 0x03, 0x5c,
	0x50, 0x3a, 0xc8, 0x14, 0xb0, 0x01, 0x6b, 0xb9, 0x98, 0x81, 0x4c, 0xd4, 0xad, 0x39, 0xf3, 0x25,
	0x36, 0xa1, 0x3e, 0xa4, 0x11, 0xbd, 0x61, 0x1e, 0x23, 0xf1, 0xcc, 0x78, 0xa3, 0xa3, 0x45, 0x08,
	0x7f, 0x0a, 0x8d, 0x90, 0xa4, 0x6e, 0x40, 0x84, 0x3b, 0xa1, 0xb1, 0x2b, 0x53, 0xa3, 0x6c, 0xa2,
	0x6e, 0xc5, 0xa9, 0x87, 0x24, 0xed, 0x13, 0xf1, 0x3d, 0x8d, 0xaf, 0x52, 0xdc, 0x85, 0xa6, 0xe4,
	0x92, 0x8c, 0x35, 0x6d, 0x98, 0xf8, 0x01, 0x95, 0x46, 0x45, 0xd3, 0x1a, 0x1a, 0xef, 0x13, 0xd1,
	0xd3, 0x28, 0xfe, 0x12, 0x36, 0x69, 0x3a, 0x61, 0x31, 0x91, 0x8c, 0x47, 0xee, 0x88, 0xb2, 0x60,
	0x24, 0x8d, 0xb7, 0x26, 0xea, 0x96, 0x9d, 0xe6, 0x22, 0xf0, 0xad, 0xc6, 0xf1, 0x1e, 0x80, 0x17,
	0x53, 0x22, 0xa9, 0xef, 0x12, 0x69, 0xbc, 0xd3, 0xac, 0x5a, 0x8e, 0x9c, 0x49, 0xfc, 0x19, 0x34,
	0x0a, 0x77, 0xe8, 0x32, 0xdf, 0x58, 0xd3, 0xe7, 0x5f, 0x2f, 0xa0, 0x97, 0x3e, 0xde, 0x85, 0x1a,
	0x13, 0x2e, 0xf1, 0x24, 0x9b, 0x52, 0xa3, 0x6a, 0xa2, 0x6e, 0xd5, 0xa9, 0x32, 0x71, 0xa6, 0xd7,
	0xb8, 0x0f, 0xe0, 0xf1, 0xc8, 0x67, 0x4a, 0x55, 0x18, 0x35, 0x13, 0x75, 0xeb, 0x87, 0xfb, 0xd6,
	0xbf, 0xeb, 0x60, 0x0d, 0x16, 0x19, 0xcf, 0x5f, 0xe8, 0x4e, 0x61, 0x2b, 0xfe, 0x18, 0xaa, 0xca,
	0x7c, 0x22, 0xa8, 0x6f, 0x80, 0xb6, 0xbe, 0x16, 0x10, 0x71, 0x2d, 0xa8, 0xaf, 0x3c, 0xcb, 0x98,
	0x44, 0x42, 0x1d, 0x81, 0x47, 0xae, 0xc7, 0x93, 0x48, 0x1a, 0x75, 0xcd, 0x69, 0x16, 0x02, 0xe7,
	0x0a, 0x3f, 0xa9, 0x3c, 0xff, 0xde, 0x46, 0x9d, 0x67, 0x04, 0xdb, 0x2b, 0x35, 0xf1, 0x11, 0x6c,
	0xff, 0x3a, 0x62, 0x92, 0x8e, 0x99, 0x50, 0xf7, 0xe2, 0xf1, 0x48, 0xc6, 0xc4, 0x93, 0xc2, 0x40,
	0x66, 0xb9, 0x5b, 0x73, 0xb6, 0x0a, 0xc1, 0xf3, 0x79, 0x0c, 0x9f, 0xc2, 0x7b, 0x55, 0x44, 0x99,
	0xba, 0x53, 0x32, 0x4e, 0x68, 0x56, 0xe7, 0xde, 0xde, 0xdd, 0x43, 0xbb, 0xf4, 0xd7, 0x43, 0x7b,
	0x3b, 0xb3, 0x2b, 0xfc, 0x5b, 0x8b, 0x71, 0x3b, 0x24, 0x72, 0x64, 0x5d, 0x46, 0xd2, 0x81, 0x90,
	0xa4, 0x57, 0xe9, 0x0f, 0x6a, 0x03, 0xfe, 0x1c, 0x36, 0x7c, 0xc2, 0xc6, 0x33, 0x5d, 0xe0, 0x31,
	0x0b, 0x99, 0xcc, 0xdb, 0x60, 0x5d, 0xc3, 0x7d, 0x22, 0xbe, 0x53, 0xa0, 0xb2, 0x1a, 0xd3, 0x5f,
	0x12, 0x16, 0x53, 0x57, 0xb0, 0x20, 0x22, 0x32, 0x89, 0xa9, 0xee, 0x84, 0xaa, 0xd3, 0xcc, 0x03,
	0x83, 0x39, 0x9e, 0x5b, 0x7d, 0x40, 0xf0, 0x41, 0xc1, 0xaa, 0x43, 0x03, 0x26, 0x64, 0x3c, 0xc3,
	0x3f, 0xc1, 0xfb, 0x42, 0x1d, 0x33, 0x7f, 0xf5, 0xc3, 0xaf, 0xfe, 0xb7, 0x36, 0xf3, 0xcd, 0x45,
	0x4c, 0x7c, 0x13, 0xc9, 0x78, 0xe6, 0x2c, 0x25, 0xdb, 0xf9, 0x19, 0x36, 0x5f, 0x51, 0x70, 0x13,
	0xca, 0xb7, 0x74, 0x96, 0x8f, 0x88, 0xfa, 0xc5, 0xa7, 0xf0, 0x76, 0x71, 0x61, 0xf5, 0xc3, 0x2f,
	0x5e, 0x8b, 0xf7, 0x16, 0xa3, 0x52, 0x4c, 0xe8, 0x64, 0xfb, 0x4e, 0xde, 0x1c, 0xa3, 0xce, 0x00,
	0x3e, 0xfa, 0x0f, 0x16, 0x3e, 0x86, 0xea, 0xfc, 0x58, 0xb9, 0xbf, 0x4f, 0x5e, 0x4b, 0x2c, 0x06,
	0xd9, 0x79, 0x61, 0x77, 0x22, 0xf8, 0xb0, 0x90, 0xe9, 0x5a, 0x90, 0x80, 0x3a, 0xd4, 0xe3, 0xb1,
	0xbf, 0x62, 0x2a, 0xd0, 0xaa, 0xa9, 0xc0, 0x50, 0xf1, 0x89, 0xcc, 0x9c, 0x95, 0x1d, 0xfd, 0xbf,
	0xd4, 0xc3, 0xe5, 0xa5, 0x1e, 0xee, 0x5c, 0xc0, 0xee, 0x6a, 0x13, 0x97, 0x91, 0x4f, 0x53, 0xbc,
	0x0f, 0x1b, 0xcb, 0xa2, 0xf3, 0x7e, 0x6c, 0x2c, 0xa9, 0x8a, 0xce, 0x3e, 0xc0, 0xd7, 0xaa, 0x63,
	0xf4, 0x89, 0x97, 0x04, 0xd1, 0x92, 0x60, 0xef, 0xe4, 0xee, 0xb1, 0x85, 0xee, 0x1f, 0x5b, 0xe8,
	0xef, 0xc7, 0x16, 0xfa, 0xed, 0xa9, 0x55, 0xba, 0x7f, 0x6a, 0x95, 0xfe, 0x7c, 0x6a, 0x95, 0x7e,
	0x34, 0x03, 0x26, 0x47, 0xc9, 0xd0, 0xf2, 0x78, 0x68, 0x17, 0x1e, 0xd5, 0x54, 0x3d, 0xab, 0x72,
	0x36, 0xa1, 0x62, 0xf8, 0x4e, 0xbf, 0x82, 0x47, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xc0, 0x31,
	0x3e, 0x15, 0x74, 0x05, 0x00, 0x00,
}

func (this *FeeSponsor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FeeSponsor)
	if !ok {
		that2, ok := that.(FeeSponsor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Sponsor != that1.Sponsor {
		return false
	}
	if this.Beneficiary != that1.Beneficiary {
		return false
	}
	if this.MaxGasPerTx != that1.MaxGasPerTx {
		return false
	}
	if this.TotalGasBudget != that1.TotalGasBudget {
		return false
	}
	if this.ExpirationHeight != that1.ExpirationHeight {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.SponsorshipId != that1.SponsorshipId {
		return false
	}
	if this.IsActive != that1.IsActive {
		return false
	}
	if !this.Conditions.Equal(that1.Conditions) {
		return false
	}
	if this.GasUsed != that1.GasUsed {
		return false
	}
	if this.TransactionCount != that1.TransactionCount {
		return false
	}
	return true
}
func (this *SponsorshipConditions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SponsorshipConditions)
	if !ok {
		that2, ok := that.(SponsorshipConditions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.WhitelistedContracts) != len(that1.WhitelistedContracts) {
		return false
	}
	for i := range this.WhitelistedContracts {
		if this.WhitelistedContracts[i] != that1.WhitelistedContracts[i] {
			return false
		}
	}
	if !this.MaxTxValue.Equal(that1.MaxTxValue) {
		return false
	}
	if this.DailyGasLimit != that1.DailyGasLimit {
		return false
	}
	if this.RequireSignature != that1.RequireSignature {
		return false
	}
	return true
}
func (m *FeeSponsor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FeeSponsor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FeeSponsor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TransactionCount != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.TransactionCount))
		i--
		dAtA[i] = 0x58
	}
	if m.GasUsed != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x50
	}
	if m.Conditions != nil {
		{
			size, err := m.Conditions.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSponsorship(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.SponsorshipId) > 0 {
		i -= len(m.SponsorshipId)
		copy(dAtA[i:], m.SponsorshipId)
		i = encodeVarintSponsorship(dAtA, i, uint64(len(m.SponsorshipId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.CreatedAt != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.ExpirationHeight != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.ExpirationHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalGasBudget != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.TotalGasBudget))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxGasPerTx != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.MaxGasPerTx))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Beneficiary) > 0 {
		i -= len(m.Beneficiary)
		copy(dAtA[i:], m.Beneficiary)
		i = encodeVarintSponsorship(dAtA, i, uint64(len(m.Beneficiary)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sponsor) > 0 {
		i -= len(m.Sponsor)
		copy(dAtA[i:], m.Sponsor)
		i = encodeVarintSponsorship(dAtA, i, uint64(len(m.Sponsor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SponsorshipConditions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SponsorshipConditions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SponsorshipConditions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequireSignature {
		i--
		if m.RequireSignature {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.DailyGasLimit != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.DailyGasLimit))
		i--
		dAtA[i] = 0x18
	}
	{
		size := m.MaxTxValue.Size()
		i -= size
		if _, err := m.MaxTxValue.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintSponsorship(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.WhitelistedContracts) > 0 {
		for iNdEx := len(m.WhitelistedContracts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.WhitelistedContracts[iNdEx])
			copy(dAtA[i:], m.WhitelistedContracts[iNdEx])
			i = encodeVarintSponsorship(dAtA, i, uint64(len(m.WhitelistedContracts[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SponsorshipRegistry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SponsorshipRegistry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SponsorshipRegistry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sponsorships) > 0 {
		for k := range m.Sponsorships {
			v := m.Sponsorships[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSponsorship(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSponsorship(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSponsorship(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BeneficiarySponsorships) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeneficiarySponsorships) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeneficiarySponsorships) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sponsors) > 0 {
		for iNdEx := len(m.Sponsors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sponsors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSponsorship(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SponsorshipUsageRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SponsorshipUsageRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SponsorshipUsageRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GasUsed != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x18
	}
	if m.Date != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SponsorshipId) > 0 {
		i -= len(m.SponsorshipId)
		copy(dAtA[i:], m.SponsorshipId)
		i = encodeVarintSponsorship(dAtA, i, uint64(len(m.SponsorshipId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BeneficiarySponsorshipIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeneficiarySponsorshipIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BeneficiarySponsorshipIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SponsorshipIds) > 0 {
		for iNdEx := len(m.SponsorshipIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SponsorshipIds[iNdEx])
			copy(dAtA[i:], m.SponsorshipIds[iNdEx])
			i = encodeVarintSponsorship(dAtA, i, uint64(len(m.SponsorshipIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DailyUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DailyUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GasUsed != 0 {
		i = encodeVarintSponsorship(dAtA, i, uint64(m.GasUsed))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintSponsorship(dAtA []byte, offset int, v uint64) int {
	offset -= sovSponsorship(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FeeSponsor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sponsor)
	if l > 0 {
		n += 1 + l + sovSponsorship(uint64(l))
	}
	l = len(m.Beneficiary)
	if l > 0 {
		n += 1 + l + sovSponsorship(uint64(l))
	}
	if m.MaxGasPerTx != 0 {
		n += 1 + sovSponsorship(uint64(m.MaxGasPerTx))
	}
	if m.TotalGasBudget != 0 {
		n += 1 + sovSponsorship(uint64(m.TotalGasBudget))
	}
	if m.ExpirationHeight != 0 {
		n += 1 + sovSponsorship(uint64(m.ExpirationHeight))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovSponsorship(uint64(m.CreatedAt))
	}
	l = len(m.SponsorshipId)
	if l > 0 {
		n += 1 + l + sovSponsorship(uint64(l))
	}
	if m.IsActive {
		n += 2
	}
	if m.Conditions != nil {
		l = m.Conditions.Size()
		n += 1 + l + sovSponsorship(uint64(l))
	}
	if m.GasUsed != 0 {
		n += 1 + sovSponsorship(uint64(m.GasUsed))
	}
	if m.TransactionCount != 0 {
		n += 1 + sovSponsorship(uint64(m.TransactionCount))
	}
	return n
}

func (m *SponsorshipConditions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WhitelistedContracts) > 0 {
		for _, s := range m.WhitelistedContracts {
			l = len(s)
			n += 1 + l + sovSponsorship(uint64(l))
		}
	}
	l = m.MaxTxValue.Size()
	n += 1 + l + sovSponsorship(uint64(l))
	if m.DailyGasLimit != 0 {
		n += 1 + sovSponsorship(uint64(m.DailyGasLimit))
	}
	if m.RequireSignature {
		n += 2
	}
	return n
}

func (m *SponsorshipRegistry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sponsorships) > 0 {
		for k, v := range m.Sponsorships {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSponsorship(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSponsorship(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSponsorship(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BeneficiarySponsorships) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sponsors) > 0 {
		for _, e := range m.Sponsors {
			l = e.Size()
			n += 1 + l + sovSponsorship(uint64(l))
		}
	}
	return n
}

func (m *SponsorshipUsageRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SponsorshipId)
	if l > 0 {
		n += 1 + l + sovSponsorship(uint64(l))
	}
	if m.Date != 0 {
		n += 1 + sovSponsorship(uint64(m.Date))
	}
	if m.GasUsed != 0 {
		n += 1 + sovSponsorship(uint64(m.GasUsed))
	}
	return n
}

func (m *BeneficiarySponsorshipIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SponsorshipIds) > 0 {
		for _, s := range m.SponsorshipIds {
			l = len(s)
			n += 1 + l + sovSponsorship(uint64(l))
		}
	}
	return n
}

func (m *DailyUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GasUsed != 0 {
		n += 1 + sovSponsorship(uint64(m.GasUsed))
	}
	return n
}

func sovSponsorship(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSponsorship(x uint64) (n int) {
	return sovSponsorship(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FeeSponsor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSponsorship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FeeSponsor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FeeSponsor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sponsor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sponsor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Beneficiary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Beneficiary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxGasPerTx", wireType)
			}
			m.MaxGasPerTx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxGasPerTx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGasBudget", wireType)
			}
			m.TotalGasBudget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalGasBudget |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationHeight", wireType)
			}
			m.ExpirationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SponsorshipId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SponsorshipId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conditions == nil {
				m.Conditions = &SponsorshipConditions{}
			}
			if err := m.Conditions.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionCount", wireType)
			}
			m.TransactionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSponsorship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSponsorship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SponsorshipConditions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSponsorship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SponsorshipConditions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SponsorshipConditions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhitelistedContracts", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WhitelistedContracts = append(m.WhitelistedContracts, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxTxValue.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyGasLimit", wireType)
			}
			m.DailyGasLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DailyGasLimit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireSignature", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireSignature = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSponsorship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSponsorship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SponsorshipRegistry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSponsorship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SponsorshipRegistry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SponsorshipRegistry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sponsorships", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sponsorships == nil {
				m.Sponsorships = make(map[string]*BeneficiarySponsorships)
			}
			var mapkey string
			var mapvalue *BeneficiarySponsorships
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSponsorship
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSponsorship
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSponsorship
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSponsorship
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSponsorship
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSponsorship
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSponsorship
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &BeneficiarySponsorships{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSponsorship(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSponsorship
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Sponsorships[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSponsorship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSponsorship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeneficiarySponsorships) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSponsorship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeneficiarySponsorships: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeneficiarySponsorships: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sponsors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sponsors = append(m.Sponsors, &FeeSponsor{})
			if err := m.Sponsors[len(m.Sponsors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSponsorship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSponsorship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SponsorshipUsageRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSponsorship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SponsorshipUsageRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SponsorshipUsageRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SponsorshipId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SponsorshipId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSponsorship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSponsorship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeneficiarySponsorshipIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSponsorship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeneficiarySponsorshipIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeneficiarySponsorshipIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SponsorshipIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSponsorship
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSponsorship
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SponsorshipIds = append(m.SponsorshipIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSponsorship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSponsorship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSponsorship
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasUsed", wireType)
			}
			m.GasUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasUsed |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSponsorship(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSponsorship
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSponsorship(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSponsorship
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSponsorship
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSponsorship
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSponsorship
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSponsorship
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSponsorship        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSponsorship          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSponsorship = fmt.Errorf("proto: unexpected end of group")
)
